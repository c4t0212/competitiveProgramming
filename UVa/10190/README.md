# [UVa 10190](https://vjudge.net/problem/UVA-10190)  

給定N、M，請你判斷`N是否為M的K次方`，如果是請輸出整個次方序列，反之輸出"Boring!"  

* sol-1:  
  慢慢檢查，小心`除數和被除數為0`的狀況跟`除數為1`的狀況，若整除則塞進陣列，反之跳出迴圈，輸出時檢查陣列是否為空和最後一個數是否為M就好
  
* sol-2:  
  使用log的特性來解(以10為底)  
    
  ![image](https://github.com/c4t0212/competitiveProgramming/blob/main/UVa/10190/pic.png)  
    
  先把次方算出來，再使用次方去比對原來的N是不是一樣的(因為int會忽略小數)，如果一樣則代表N剛好是M的某個次方，則可以進行答案輸出，不一樣則輸出Boring!  
    
  **等一下，這看似很棒的公式解其實裡面有很大的bug!**  
  如果今天M = 1，則 log(M) = log(1) = 0，除法除下去就~~Explosion!~~，但正好因為除法爆炸而有一個特性可以使用，就是指數會回傳負數
  > 小科普: 如果C++遇到無限大的狀況(像是上面的例子)，則會回傳INF，不同資料型態(float, double)的INF不一樣  
  如果除法回傳INF，再轉乘int的話值會變成-2147483648(INT_MIN)，使用一個if過濾掉負數指數即可

NOTE:
  * `0 <= N、M <= 2000000000`  

---
#### 這邊來講說詳細的浮點數運算及INF!  

##### 先來介紹一下float浮點數的結構
  
  ![image](https://github.com/c4t0212/competitiveProgramming/blob/main/UVa/10190/image.png)
  ###### 圖片來源[wiki](https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8)  
    
  單精度浮點數主要分成三個區塊，共32bits  
  1. 正負區(1bit)  
      * 以0表示正數，1表示負數

  2. 指數區(8bits)(index23為第0個bit)  
      * 8bits表示共有2^8 = 256個數字，表示數字從0~255，0 ~ 126表示指數-127 ~ -1， 127表指數0，128 ~ 255表指數1 ~ 128

  3. 小數區(23bits)(index22為第1個bit)  
      * 最左方一定有一個不被記錄的bit表示1，其他照正常二進位小數計算就好  

#### 計算方式  
正負號 * 2^(指數區 - 127) * (1 + 小數區)  
  
* 舉個栗子(上方圖片):
  (+1) * 2^(124 - 127) * (1 + 2^(-2)) = 0.15625  
  FLT_MAX 則為 (+1) * 2^(254 - 127) * (1 + 2^(-1) + ... + 2^(-23))

#### 聽了那麼多廢話，INF又是啥鬼?  
INF表示正無限大，以float表示則是第一個bit為0，指數區全為1，小數區全為0
* 要如何得到INF?  
  x/0、x%0、INF+/INF...等等計算都有可能會跑出INF
* 那為何INF轉乘int型態會變成負數?  
  這還沒搞清楚他的機制，但目前轉出來的結果都是剛好INT_MIN，有可能是剛好發生溢位
  
#### 額外補充下NAN
* 他誰?  
  NAN表示Not a number，像是對負數開根號或取log都有可能得到  
* 以float表示的話指數區全為1，但小數區不定，所以NAN可能會有很多種(只要小數區不全為0就是NAN)，~~理論上來說NAN比INF還要大~~ ，但在程式中不能用NAN來比大小
